// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package im.actor.server.notify


import im.actor.server.api.TypeMappers._
import scala.collection.JavaConversions._

@SerialVersionUID(0L)
final case class NotifyProcessorEvents(
    ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[NotifyProcessorEvents] with com.trueaccord.lenses.Updatable[NotifyProcessorEvents] {
    @transient
    lazy val serializedSize: Int = {
      var __size = 0
      __size
    }
    def writeTo(output: com.google.protobuf.CodedOutputStream): Unit = {
    }
    def mergeFrom(__input: com.google.protobuf.CodedInputStream): im.actor.server.notify.NotifyProcessorEvents = {
      var _done__ = false
      while (!_done__) {
        val _tag__ = __input.readTag()
        _tag__ match {
          case 0 => _done__ = true
          case tag => __input.skipField(tag)
        }
      }
      im.actor.server.notify.NotifyProcessorEvents(
      )
    }
    def getField(__field: com.google.protobuf.Descriptors.FieldDescriptor): scala.Any = throw new MatchError(__field)
    override def toString: String = com.trueaccord.scalapb.TextFormat.printToUnicodeString(this)
    def companion = im.actor.server.notify.NotifyProcessorEvents
}

object NotifyProcessorEvents extends com.trueaccord.scalapb.GeneratedMessageCompanion[NotifyProcessorEvents]  {
  implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[NotifyProcessorEvents]  = this
  def fromFieldsMap(__fieldsMap: Map[com.google.protobuf.Descriptors.FieldDescriptor, scala.Any]): im.actor.server.notify.NotifyProcessorEvents = {
    require(__fieldsMap.keys.forall(_.getContainingType() == descriptor), "FieldDescriptor does not match message type.")
    val __fields = descriptor.getFields
    im.actor.server.notify.NotifyProcessorEvents(
    )
  }
  def descriptor: com.google.protobuf.Descriptors.Descriptor = NotifyProto.descriptor.getMessageTypes.get(0)
  def messageCompanionForField(__field: com.google.protobuf.Descriptors.FieldDescriptor): com.trueaccord.scalapb.GeneratedMessageCompanion[_] = throw new MatchError(__field)
  def enumCompanionForField(__field: com.google.protobuf.Descriptors.FieldDescriptor): com.trueaccord.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__field)
  lazy val defaultInstance = im.actor.server.notify.NotifyProcessorEvents(
  )
  @SerialVersionUID(0L)
  final case class NotifyScheduled(
      ts: java.time.Instant = im.actor.server.notify.NotifyProcessorEvents.NotifyScheduled._typemapper_ts.toCustom(0L),
      userId: Int = 0,
      at: Long = 0L
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[NotifyScheduled] with com.trueaccord.lenses.Updatable[NotifyScheduled] with im.actor.server.notify.NotifyProcessorEvent {
      @transient
      lazy val serializedSize: Int = {
        var __size = 0
        if (im.actor.server.notify.NotifyProcessorEvents.NotifyScheduled._typemapper_ts.toBase(ts) != 0L) { __size += com.google.protobuf.CodedOutputStream.computeInt64Size(1, im.actor.server.notify.NotifyProcessorEvents.NotifyScheduled._typemapper_ts.toBase(ts)) }
        if (userId != 0) { __size += com.google.protobuf.CodedOutputStream.computeInt32Size(2, userId) }
        if (at != 0L) { __size += com.google.protobuf.CodedOutputStream.computeInt64Size(3, at) }
        __size
      }
      def writeTo(output: com.google.protobuf.CodedOutputStream): Unit = {
        {
          val __v = im.actor.server.notify.NotifyProcessorEvents.NotifyScheduled._typemapper_ts.toBase(ts)
          if (__v != 0L) {
            output.writeInt64(1, __v)
          }
        };
        {
          val __v = userId
          if (__v != 0) {
            output.writeInt32(2, __v)
          }
        };
        {
          val __v = at
          if (__v != 0L) {
            output.writeInt64(3, __v)
          }
        };
      }
      def mergeFrom(__input: com.google.protobuf.CodedInputStream): im.actor.server.notify.NotifyProcessorEvents.NotifyScheduled = {
        var __ts = this.ts
        var __userId = this.userId
        var __at = this.at
        var _done__ = false
        while (!_done__) {
          val _tag__ = __input.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 8 =>
              __ts = im.actor.server.notify.NotifyProcessorEvents.NotifyScheduled._typemapper_ts.toCustom(__input.readInt64())
            case 16 =>
              __userId = __input.readInt32()
            case 24 =>
              __at = __input.readInt64()
            case tag => __input.skipField(tag)
          }
        }
        im.actor.server.notify.NotifyProcessorEvents.NotifyScheduled(
            ts = __ts,
            userId = __userId,
            at = __at
        )
      }
      def withTs(__v: java.time.Instant): NotifyScheduled = copy(ts = __v)
      def withUserId(__v: Int): NotifyScheduled = copy(userId = __v)
      def withAt(__v: Long): NotifyScheduled = copy(at = __v)
      def getField(__field: com.google.protobuf.Descriptors.FieldDescriptor): scala.Any = {
        __field.getNumber match {
          case 1 => {
            val __t = im.actor.server.notify.NotifyProcessorEvents.NotifyScheduled._typemapper_ts.toBase(ts)
            if (__t != 0L) __t else null
          }
          case 2 => {
            val __t = userId
            if (__t != 0) __t else null
          }
          case 3 => {
            val __t = at
            if (__t != 0L) __t else null
          }
        }
      }
      override def toString: String = com.trueaccord.scalapb.TextFormat.printToUnicodeString(this)
      def companion = im.actor.server.notify.NotifyProcessorEvents.NotifyScheduled
  }
  
  object NotifyScheduled extends com.trueaccord.scalapb.GeneratedMessageCompanion[NotifyScheduled]  {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[NotifyScheduled]  = this
    def fromFieldsMap(__fieldsMap: Map[com.google.protobuf.Descriptors.FieldDescriptor, scala.Any]): im.actor.server.notify.NotifyProcessorEvents.NotifyScheduled = {
      require(__fieldsMap.keys.forall(_.getContainingType() == descriptor), "FieldDescriptor does not match message type.")
      val __fields = descriptor.getFields
      im.actor.server.notify.NotifyProcessorEvents.NotifyScheduled(
        im.actor.server.notify.NotifyProcessorEvents.NotifyScheduled._typemapper_ts.toCustom(__fieldsMap.getOrElse(__fields.get(0), 0L).asInstanceOf[Long]),
        __fieldsMap.getOrElse(__fields.get(1), 0).asInstanceOf[Int],
        __fieldsMap.getOrElse(__fields.get(2), 0L).asInstanceOf[Long]
      )
    }
    def descriptor: com.google.protobuf.Descriptors.Descriptor = im.actor.server.notify.NotifyProcessorEvents.descriptor.getNestedTypes.get(0)
    def messageCompanionForField(__field: com.google.protobuf.Descriptors.FieldDescriptor): com.trueaccord.scalapb.GeneratedMessageCompanion[_] = throw new MatchError(__field)
    def enumCompanionForField(__field: com.google.protobuf.Descriptors.FieldDescriptor): com.trueaccord.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__field)
    lazy val defaultInstance = im.actor.server.notify.NotifyProcessorEvents.NotifyScheduled(
    )
    implicit class NotifyScheduledLens[UpperPB](_l: com.trueaccord.lenses.Lens[UpperPB, NotifyScheduled]) extends com.trueaccord.lenses.ObjectLens[UpperPB, NotifyScheduled](_l) {
      def ts: com.trueaccord.lenses.Lens[UpperPB, java.time.Instant] = field(_.ts)((c_, f_) => c_.copy(ts = f_))
      def userId: com.trueaccord.lenses.Lens[UpperPB, Int] = field(_.userId)((c_, f_) => c_.copy(userId = f_))
      def at: com.trueaccord.lenses.Lens[UpperPB, Long] = field(_.at)((c_, f_) => c_.copy(at = f_))
    }
    final val TS_FIELD_NUMBER = 1
    final val USER_ID_FIELD_NUMBER = 2
    final val AT_FIELD_NUMBER = 3
    private val _typemapper_ts: com.trueaccord.scalapb.TypeMapper[Long, java.time.Instant] = implicitly[com.trueaccord.scalapb.TypeMapper[Long, java.time.Instant]]
  }
  
  @SerialVersionUID(0L)
  final case class NotifyCanceled(
      ts: java.time.Instant = im.actor.server.notify.NotifyProcessorEvents.NotifyCanceled._typemapper_ts.toCustom(0L),
      userId: Int = 0
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[NotifyCanceled] with com.trueaccord.lenses.Updatable[NotifyCanceled] with im.actor.server.notify.NotifyProcessorEvent {
      @transient
      lazy val serializedSize: Int = {
        var __size = 0
        if (im.actor.server.notify.NotifyProcessorEvents.NotifyCanceled._typemapper_ts.toBase(ts) != 0L) { __size += com.google.protobuf.CodedOutputStream.computeInt64Size(1, im.actor.server.notify.NotifyProcessorEvents.NotifyCanceled._typemapper_ts.toBase(ts)) }
        if (userId != 0) { __size += com.google.protobuf.CodedOutputStream.computeInt32Size(2, userId) }
        __size
      }
      def writeTo(output: com.google.protobuf.CodedOutputStream): Unit = {
        {
          val __v = im.actor.server.notify.NotifyProcessorEvents.NotifyCanceled._typemapper_ts.toBase(ts)
          if (__v != 0L) {
            output.writeInt64(1, __v)
          }
        };
        {
          val __v = userId
          if (__v != 0) {
            output.writeInt32(2, __v)
          }
        };
      }
      def mergeFrom(__input: com.google.protobuf.CodedInputStream): im.actor.server.notify.NotifyProcessorEvents.NotifyCanceled = {
        var __ts = this.ts
        var __userId = this.userId
        var _done__ = false
        while (!_done__) {
          val _tag__ = __input.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 8 =>
              __ts = im.actor.server.notify.NotifyProcessorEvents.NotifyCanceled._typemapper_ts.toCustom(__input.readInt64())
            case 16 =>
              __userId = __input.readInt32()
            case tag => __input.skipField(tag)
          }
        }
        im.actor.server.notify.NotifyProcessorEvents.NotifyCanceled(
            ts = __ts,
            userId = __userId
        )
      }
      def withTs(__v: java.time.Instant): NotifyCanceled = copy(ts = __v)
      def withUserId(__v: Int): NotifyCanceled = copy(userId = __v)
      def getField(__field: com.google.protobuf.Descriptors.FieldDescriptor): scala.Any = {
        __field.getNumber match {
          case 1 => {
            val __t = im.actor.server.notify.NotifyProcessorEvents.NotifyCanceled._typemapper_ts.toBase(ts)
            if (__t != 0L) __t else null
          }
          case 2 => {
            val __t = userId
            if (__t != 0) __t else null
          }
        }
      }
      override def toString: String = com.trueaccord.scalapb.TextFormat.printToUnicodeString(this)
      def companion = im.actor.server.notify.NotifyProcessorEvents.NotifyCanceled
  }
  
  object NotifyCanceled extends com.trueaccord.scalapb.GeneratedMessageCompanion[NotifyCanceled]  {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[NotifyCanceled]  = this
    def fromFieldsMap(__fieldsMap: Map[com.google.protobuf.Descriptors.FieldDescriptor, scala.Any]): im.actor.server.notify.NotifyProcessorEvents.NotifyCanceled = {
      require(__fieldsMap.keys.forall(_.getContainingType() == descriptor), "FieldDescriptor does not match message type.")
      val __fields = descriptor.getFields
      im.actor.server.notify.NotifyProcessorEvents.NotifyCanceled(
        im.actor.server.notify.NotifyProcessorEvents.NotifyCanceled._typemapper_ts.toCustom(__fieldsMap.getOrElse(__fields.get(0), 0L).asInstanceOf[Long]),
        __fieldsMap.getOrElse(__fields.get(1), 0).asInstanceOf[Int]
      )
    }
    def descriptor: com.google.protobuf.Descriptors.Descriptor = im.actor.server.notify.NotifyProcessorEvents.descriptor.getNestedTypes.get(1)
    def messageCompanionForField(__field: com.google.protobuf.Descriptors.FieldDescriptor): com.trueaccord.scalapb.GeneratedMessageCompanion[_] = throw new MatchError(__field)
    def enumCompanionForField(__field: com.google.protobuf.Descriptors.FieldDescriptor): com.trueaccord.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__field)
    lazy val defaultInstance = im.actor.server.notify.NotifyProcessorEvents.NotifyCanceled(
    )
    implicit class NotifyCanceledLens[UpperPB](_l: com.trueaccord.lenses.Lens[UpperPB, NotifyCanceled]) extends com.trueaccord.lenses.ObjectLens[UpperPB, NotifyCanceled](_l) {
      def ts: com.trueaccord.lenses.Lens[UpperPB, java.time.Instant] = field(_.ts)((c_, f_) => c_.copy(ts = f_))
      def userId: com.trueaccord.lenses.Lens[UpperPB, Int] = field(_.userId)((c_, f_) => c_.copy(userId = f_))
    }
    final val TS_FIELD_NUMBER = 1
    final val USER_ID_FIELD_NUMBER = 2
    private val _typemapper_ts: com.trueaccord.scalapb.TypeMapper[Long, java.time.Instant] = implicitly[com.trueaccord.scalapb.TypeMapper[Long, java.time.Instant]]
  }
  
  @SerialVersionUID(0L)
  final case class NewUsersAdded(
      ts: java.time.Instant = im.actor.server.notify.NotifyProcessorEvents.NewUsersAdded._typemapper_ts.toCustom(0L),
      userIds: Seq[Int] = Nil,
      lastUserRegisterDate: Long = 0L
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[NewUsersAdded] with com.trueaccord.lenses.Updatable[NewUsersAdded] with im.actor.server.notify.NotifyProcessorEvent {
      lazy val userIdsSerializedSize =
        userIds.map(com.google.protobuf.CodedOutputStream.computeInt32SizeNoTag).sum
      @transient
      lazy val serializedSize: Int = {
        var __size = 0
        if (im.actor.server.notify.NotifyProcessorEvents.NewUsersAdded._typemapper_ts.toBase(ts) != 0L) { __size += com.google.protobuf.CodedOutputStream.computeInt64Size(1, im.actor.server.notify.NotifyProcessorEvents.NewUsersAdded._typemapper_ts.toBase(ts)) }
        if(userIds.nonEmpty) {
          __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(userIdsSerializedSize) + userIdsSerializedSize
        }
        if (lastUserRegisterDate != 0L) { __size += com.google.protobuf.CodedOutputStream.computeInt64Size(3, lastUserRegisterDate) }
        __size
      }
      def writeTo(output: com.google.protobuf.CodedOutputStream): Unit = {
        {
          val __v = im.actor.server.notify.NotifyProcessorEvents.NewUsersAdded._typemapper_ts.toBase(ts)
          if (__v != 0L) {
            output.writeInt64(1, __v)
          }
        };
        if (userIds.nonEmpty) {
          output.writeTag(2, 2)
          output.writeRawVarint32(userIdsSerializedSize)
          userIds.foreach(output.writeInt32NoTag)
        };
        {
          val __v = lastUserRegisterDate
          if (__v != 0L) {
            output.writeInt64(3, __v)
          }
        };
      }
      def mergeFrom(__input: com.google.protobuf.CodedInputStream): im.actor.server.notify.NotifyProcessorEvents.NewUsersAdded = {
        var __ts = this.ts
        val __userIds = (scala.collection.immutable.Vector.newBuilder[Int] ++= this.userIds)
        var __lastUserRegisterDate = this.lastUserRegisterDate
        var _done__ = false
        while (!_done__) {
          val _tag__ = __input.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 8 =>
              __ts = im.actor.server.notify.NotifyProcessorEvents.NewUsersAdded._typemapper_ts.toCustom(__input.readInt64())
            case 18 => {
              val length = __input.readRawVarint32()
              val oldLimit = __input.pushLimit(length)
              while (__input.getBytesUntilLimit > 0) {
                __userIds += __input.readInt32
              }
              __input.popLimit(oldLimit)
            }
            case 24 =>
              __lastUserRegisterDate = __input.readInt64()
            case tag => __input.skipField(tag)
          }
        }
        im.actor.server.notify.NotifyProcessorEvents.NewUsersAdded(
            ts = __ts,
            userIds = __userIds.result(),
            lastUserRegisterDate = __lastUserRegisterDate
        )
      }
      def withTs(__v: java.time.Instant): NewUsersAdded = copy(ts = __v)
      def clearUserIds = copy(userIds = Seq.empty)
      def addUserIds(__vs: Int*): NewUsersAdded = addAllUserIds(__vs)
      def addAllUserIds(__vs: TraversableOnce[Int]): NewUsersAdded = copy(userIds = userIds ++ __vs)
      def withUserIds(__v: Seq[Int]): NewUsersAdded = copy(userIds = __v)
      def withLastUserRegisterDate(__v: Long): NewUsersAdded = copy(lastUserRegisterDate = __v)
      def getField(__field: com.google.protobuf.Descriptors.FieldDescriptor): scala.Any = {
        __field.getNumber match {
          case 1 => {
            val __t = im.actor.server.notify.NotifyProcessorEvents.NewUsersAdded._typemapper_ts.toBase(ts)
            if (__t != 0L) __t else null
          }
          case 2 => userIds
          case 3 => {
            val __t = lastUserRegisterDate
            if (__t != 0L) __t else null
          }
        }
      }
      override def toString: String = com.trueaccord.scalapb.TextFormat.printToUnicodeString(this)
      def companion = im.actor.server.notify.NotifyProcessorEvents.NewUsersAdded
  }
  
  object NewUsersAdded extends com.trueaccord.scalapb.GeneratedMessageCompanion[NewUsersAdded]  {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[NewUsersAdded]  = this
    def fromFieldsMap(__fieldsMap: Map[com.google.protobuf.Descriptors.FieldDescriptor, scala.Any]): im.actor.server.notify.NotifyProcessorEvents.NewUsersAdded = {
      require(__fieldsMap.keys.forall(_.getContainingType() == descriptor), "FieldDescriptor does not match message type.")
      val __fields = descriptor.getFields
      im.actor.server.notify.NotifyProcessorEvents.NewUsersAdded(
        im.actor.server.notify.NotifyProcessorEvents.NewUsersAdded._typemapper_ts.toCustom(__fieldsMap.getOrElse(__fields.get(0), 0L).asInstanceOf[Long]),
        __fieldsMap.getOrElse(__fields.get(1), Nil).asInstanceOf[Seq[Int]],
        __fieldsMap.getOrElse(__fields.get(2), 0L).asInstanceOf[Long]
      )
    }
    def descriptor: com.google.protobuf.Descriptors.Descriptor = im.actor.server.notify.NotifyProcessorEvents.descriptor.getNestedTypes.get(2)
    def messageCompanionForField(__field: com.google.protobuf.Descriptors.FieldDescriptor): com.trueaccord.scalapb.GeneratedMessageCompanion[_] = throw new MatchError(__field)
    def enumCompanionForField(__field: com.google.protobuf.Descriptors.FieldDescriptor): com.trueaccord.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__field)
    lazy val defaultInstance = im.actor.server.notify.NotifyProcessorEvents.NewUsersAdded(
    )
    implicit class NewUsersAddedLens[UpperPB](_l: com.trueaccord.lenses.Lens[UpperPB, NewUsersAdded]) extends com.trueaccord.lenses.ObjectLens[UpperPB, NewUsersAdded](_l) {
      def ts: com.trueaccord.lenses.Lens[UpperPB, java.time.Instant] = field(_.ts)((c_, f_) => c_.copy(ts = f_))
      def userIds: com.trueaccord.lenses.Lens[UpperPB, Seq[Int]] = field(_.userIds)((c_, f_) => c_.copy(userIds = f_))
      def lastUserRegisterDate: com.trueaccord.lenses.Lens[UpperPB, Long] = field(_.lastUserRegisterDate)((c_, f_) => c_.copy(lastUserRegisterDate = f_))
    }
    final val TS_FIELD_NUMBER = 1
    final val USER_IDS_FIELD_NUMBER = 2
    final val LAST_USER_REGISTER_DATE_FIELD_NUMBER = 3
    private val _typemapper_ts: com.trueaccord.scalapb.TypeMapper[Long, java.time.Instant] = implicitly[com.trueaccord.scalapb.TypeMapper[Long, java.time.Instant]]
  }
  
  implicit class NotifyProcessorEventsLens[UpperPB](_l: com.trueaccord.lenses.Lens[UpperPB, NotifyProcessorEvents]) extends com.trueaccord.lenses.ObjectLens[UpperPB, NotifyProcessorEvents](_l) {
  }
}
