// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package im.actor.server.notify


import im.actor.server.api.TypeMappers._
import scala.collection.JavaConversions._

@SerialVersionUID(0L)
final case class NotifyProcessorCommands(
    ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[NotifyProcessorCommands] with com.trueaccord.lenses.Updatable[NotifyProcessorCommands] {
    @transient
    lazy val serializedSize: Int = {
      var __size = 0
      __size
    }
    def writeTo(output: com.google.protobuf.CodedOutputStream): Unit = {
    }
    def mergeFrom(__input: com.google.protobuf.CodedInputStream): im.actor.server.notify.NotifyProcessorCommands = {
      var _done__ = false
      while (!_done__) {
        val _tag__ = __input.readTag()
        _tag__ match {
          case 0 => _done__ = true
          case tag => __input.skipField(tag)
        }
      }
      im.actor.server.notify.NotifyProcessorCommands(
      )
    }
    def getField(__field: com.google.protobuf.Descriptors.FieldDescriptor): scala.Any = throw new MatchError(__field)
    override def toString: String = com.trueaccord.scalapb.TextFormat.printToUnicodeString(this)
    def companion = im.actor.server.notify.NotifyProcessorCommands
}

object NotifyProcessorCommands extends com.trueaccord.scalapb.GeneratedMessageCompanion[NotifyProcessorCommands]  {
  implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[NotifyProcessorCommands]  = this
  def fromFieldsMap(__fieldsMap: Map[com.google.protobuf.Descriptors.FieldDescriptor, scala.Any]): im.actor.server.notify.NotifyProcessorCommands = {
    require(__fieldsMap.keys.forall(_.getContainingType() == descriptor), "FieldDescriptor does not match message type.")
    val __fields = descriptor.getFields
    im.actor.server.notify.NotifyProcessorCommands(
    )
  }
  def descriptor: com.google.protobuf.Descriptors.Descriptor = NotifyProto.descriptor.getMessageTypes.get(1)
  def messageCompanionForField(__field: com.google.protobuf.Descriptors.FieldDescriptor): com.trueaccord.scalapb.GeneratedMessageCompanion[_] = throw new MatchError(__field)
  def enumCompanionForField(__field: com.google.protobuf.Descriptors.FieldDescriptor): com.trueaccord.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__field)
  lazy val defaultInstance = im.actor.server.notify.NotifyProcessorCommands(
  )
  @SerialVersionUID(0L)
  final case class FindNewUsers(
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[FindNewUsers] with com.trueaccord.lenses.Updatable[FindNewUsers] with im.actor.server.notify.NotifyProcessorCommand {
      @transient
      lazy val serializedSize: Int = {
        var __size = 0
        __size
      }
      def writeTo(output: com.google.protobuf.CodedOutputStream): Unit = {
      }
      def mergeFrom(__input: com.google.protobuf.CodedInputStream): im.actor.server.notify.NotifyProcessorCommands.FindNewUsers = {
        var _done__ = false
        while (!_done__) {
          val _tag__ = __input.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case tag => __input.skipField(tag)
          }
        }
        im.actor.server.notify.NotifyProcessorCommands.FindNewUsers(
        )
      }
      def getField(__field: com.google.protobuf.Descriptors.FieldDescriptor): scala.Any = throw new MatchError(__field)
      override def toString: String = com.trueaccord.scalapb.TextFormat.printToUnicodeString(this)
      def companion = im.actor.server.notify.NotifyProcessorCommands.FindNewUsers
  }
  
  object FindNewUsers extends com.trueaccord.scalapb.GeneratedMessageCompanion[FindNewUsers]  {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[FindNewUsers]  = this
    def fromFieldsMap(__fieldsMap: Map[com.google.protobuf.Descriptors.FieldDescriptor, scala.Any]): im.actor.server.notify.NotifyProcessorCommands.FindNewUsers = {
      require(__fieldsMap.keys.forall(_.getContainingType() == descriptor), "FieldDescriptor does not match message type.")
      val __fields = descriptor.getFields
      im.actor.server.notify.NotifyProcessorCommands.FindNewUsers(
      )
    }
    def descriptor: com.google.protobuf.Descriptors.Descriptor = im.actor.server.notify.NotifyProcessorCommands.descriptor.getNestedTypes.get(0)
    def messageCompanionForField(__field: com.google.protobuf.Descriptors.FieldDescriptor): com.trueaccord.scalapb.GeneratedMessageCompanion[_] = throw new MatchError(__field)
    def enumCompanionForField(__field: com.google.protobuf.Descriptors.FieldDescriptor): com.trueaccord.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__field)
    lazy val defaultInstance = im.actor.server.notify.NotifyProcessorCommands.FindNewUsers(
    )
    implicit class FindNewUsersLens[UpperPB](_l: com.trueaccord.lenses.Lens[UpperPB, FindNewUsers]) extends com.trueaccord.lenses.ObjectLens[UpperPB, FindNewUsers](_l) {
    }
  }
  
  @SerialVersionUID(0L)
  final case class FindNewUsersResponse(
      userIds: Seq[Int] = Nil,
      lastUserRegisterDate: Long = 0L
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[FindNewUsersResponse] with com.trueaccord.lenses.Updatable[FindNewUsersResponse] {
      lazy val userIdsSerializedSize =
        userIds.map(com.google.protobuf.CodedOutputStream.computeInt32SizeNoTag).sum
      @transient
      lazy val serializedSize: Int = {
        var __size = 0
        if(userIds.nonEmpty) {
          __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(userIdsSerializedSize) + userIdsSerializedSize
        }
        if (lastUserRegisterDate != 0L) { __size += com.google.protobuf.CodedOutputStream.computeInt64Size(2, lastUserRegisterDate) }
        __size
      }
      def writeTo(output: com.google.protobuf.CodedOutputStream): Unit = {
        if (userIds.nonEmpty) {
          output.writeTag(1, 2)
          output.writeRawVarint32(userIdsSerializedSize)
          userIds.foreach(output.writeInt32NoTag)
        };
        {
          val __v = lastUserRegisterDate
          if (__v != 0L) {
            output.writeInt64(2, __v)
          }
        };
      }
      def mergeFrom(__input: com.google.protobuf.CodedInputStream): im.actor.server.notify.NotifyProcessorCommands.FindNewUsersResponse = {
        val __userIds = (scala.collection.immutable.Vector.newBuilder[Int] ++= this.userIds)
        var __lastUserRegisterDate = this.lastUserRegisterDate
        var _done__ = false
        while (!_done__) {
          val _tag__ = __input.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 10 => {
              val length = __input.readRawVarint32()
              val oldLimit = __input.pushLimit(length)
              while (__input.getBytesUntilLimit > 0) {
                __userIds += __input.readInt32
              }
              __input.popLimit(oldLimit)
            }
            case 16 =>
              __lastUserRegisterDate = __input.readInt64()
            case tag => __input.skipField(tag)
          }
        }
        im.actor.server.notify.NotifyProcessorCommands.FindNewUsersResponse(
            userIds = __userIds.result(),
            lastUserRegisterDate = __lastUserRegisterDate
        )
      }
      def clearUserIds = copy(userIds = Seq.empty)
      def addUserIds(__vs: Int*): FindNewUsersResponse = addAllUserIds(__vs)
      def addAllUserIds(__vs: TraversableOnce[Int]): FindNewUsersResponse = copy(userIds = userIds ++ __vs)
      def withUserIds(__v: Seq[Int]): FindNewUsersResponse = copy(userIds = __v)
      def withLastUserRegisterDate(__v: Long): FindNewUsersResponse = copy(lastUserRegisterDate = __v)
      def getField(__field: com.google.protobuf.Descriptors.FieldDescriptor): scala.Any = {
        __field.getNumber match {
          case 1 => userIds
          case 2 => {
            val __t = lastUserRegisterDate
            if (__t != 0L) __t else null
          }
        }
      }
      override def toString: String = com.trueaccord.scalapb.TextFormat.printToUnicodeString(this)
      def companion = im.actor.server.notify.NotifyProcessorCommands.FindNewUsersResponse
  }
  
  object FindNewUsersResponse extends com.trueaccord.scalapb.GeneratedMessageCompanion[FindNewUsersResponse]  {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[FindNewUsersResponse]  = this
    def fromFieldsMap(__fieldsMap: Map[com.google.protobuf.Descriptors.FieldDescriptor, scala.Any]): im.actor.server.notify.NotifyProcessorCommands.FindNewUsersResponse = {
      require(__fieldsMap.keys.forall(_.getContainingType() == descriptor), "FieldDescriptor does not match message type.")
      val __fields = descriptor.getFields
      im.actor.server.notify.NotifyProcessorCommands.FindNewUsersResponse(
        __fieldsMap.getOrElse(__fields.get(0), Nil).asInstanceOf[Seq[Int]],
        __fieldsMap.getOrElse(__fields.get(1), 0L).asInstanceOf[Long]
      )
    }
    def descriptor: com.google.protobuf.Descriptors.Descriptor = im.actor.server.notify.NotifyProcessorCommands.descriptor.getNestedTypes.get(1)
    def messageCompanionForField(__field: com.google.protobuf.Descriptors.FieldDescriptor): com.trueaccord.scalapb.GeneratedMessageCompanion[_] = throw new MatchError(__field)
    def enumCompanionForField(__field: com.google.protobuf.Descriptors.FieldDescriptor): com.trueaccord.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__field)
    lazy val defaultInstance = im.actor.server.notify.NotifyProcessorCommands.FindNewUsersResponse(
    )
    implicit class FindNewUsersResponseLens[UpperPB](_l: com.trueaccord.lenses.Lens[UpperPB, FindNewUsersResponse]) extends com.trueaccord.lenses.ObjectLens[UpperPB, FindNewUsersResponse](_l) {
      def userIds: com.trueaccord.lenses.Lens[UpperPB, Seq[Int]] = field(_.userIds)((c_, f_) => c_.copy(userIds = f_))
      def lastUserRegisterDate: com.trueaccord.lenses.Lens[UpperPB, Long] = field(_.lastUserRegisterDate)((c_, f_) => c_.copy(lastUserRegisterDate = f_))
    }
    final val USER_IDS_FIELD_NUMBER = 1
    final val LAST_USER_REGISTER_DATE_FIELD_NUMBER = 2
  }
  
  @SerialVersionUID(0L)
  final case class SubscribeToPresence(
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[SubscribeToPresence] with com.trueaccord.lenses.Updatable[SubscribeToPresence] with im.actor.server.notify.NotifyProcessorCommand {
      @transient
      lazy val serializedSize: Int = {
        var __size = 0
        __size
      }
      def writeTo(output: com.google.protobuf.CodedOutputStream): Unit = {
      }
      def mergeFrom(__input: com.google.protobuf.CodedInputStream): im.actor.server.notify.NotifyProcessorCommands.SubscribeToPresence = {
        var _done__ = false
        while (!_done__) {
          val _tag__ = __input.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case tag => __input.skipField(tag)
          }
        }
        im.actor.server.notify.NotifyProcessorCommands.SubscribeToPresence(
        )
      }
      def getField(__field: com.google.protobuf.Descriptors.FieldDescriptor): scala.Any = throw new MatchError(__field)
      override def toString: String = com.trueaccord.scalapb.TextFormat.printToUnicodeString(this)
      def companion = im.actor.server.notify.NotifyProcessorCommands.SubscribeToPresence
  }
  
  object SubscribeToPresence extends com.trueaccord.scalapb.GeneratedMessageCompanion[SubscribeToPresence]  {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[SubscribeToPresence]  = this
    def fromFieldsMap(__fieldsMap: Map[com.google.protobuf.Descriptors.FieldDescriptor, scala.Any]): im.actor.server.notify.NotifyProcessorCommands.SubscribeToPresence = {
      require(__fieldsMap.keys.forall(_.getContainingType() == descriptor), "FieldDescriptor does not match message type.")
      val __fields = descriptor.getFields
      im.actor.server.notify.NotifyProcessorCommands.SubscribeToPresence(
      )
    }
    def descriptor: com.google.protobuf.Descriptors.Descriptor = im.actor.server.notify.NotifyProcessorCommands.descriptor.getNestedTypes.get(2)
    def messageCompanionForField(__field: com.google.protobuf.Descriptors.FieldDescriptor): com.trueaccord.scalapb.GeneratedMessageCompanion[_] = throw new MatchError(__field)
    def enumCompanionForField(__field: com.google.protobuf.Descriptors.FieldDescriptor): com.trueaccord.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__field)
    lazy val defaultInstance = im.actor.server.notify.NotifyProcessorCommands.SubscribeToPresence(
    )
    implicit class SubscribeToPresenceLens[UpperPB](_l: com.trueaccord.lenses.Lens[UpperPB, SubscribeToPresence]) extends com.trueaccord.lenses.ObjectLens[UpperPB, SubscribeToPresence](_l) {
    }
  }
  
  @SerialVersionUID(0L)
  final case class CheckNotify(
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[CheckNotify] with com.trueaccord.lenses.Updatable[CheckNotify] with im.actor.server.notify.NotifyProcessorCommand {
      @transient
      lazy val serializedSize: Int = {
        var __size = 0
        __size
      }
      def writeTo(output: com.google.protobuf.CodedOutputStream): Unit = {
      }
      def mergeFrom(__input: com.google.protobuf.CodedInputStream): im.actor.server.notify.NotifyProcessorCommands.CheckNotify = {
        var _done__ = false
        while (!_done__) {
          val _tag__ = __input.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case tag => __input.skipField(tag)
          }
        }
        im.actor.server.notify.NotifyProcessorCommands.CheckNotify(
        )
      }
      def getField(__field: com.google.protobuf.Descriptors.FieldDescriptor): scala.Any = throw new MatchError(__field)
      override def toString: String = com.trueaccord.scalapb.TextFormat.printToUnicodeString(this)
      def companion = im.actor.server.notify.NotifyProcessorCommands.CheckNotify
  }
  
  object CheckNotify extends com.trueaccord.scalapb.GeneratedMessageCompanion[CheckNotify]  {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[CheckNotify]  = this
    def fromFieldsMap(__fieldsMap: Map[com.google.protobuf.Descriptors.FieldDescriptor, scala.Any]): im.actor.server.notify.NotifyProcessorCommands.CheckNotify = {
      require(__fieldsMap.keys.forall(_.getContainingType() == descriptor), "FieldDescriptor does not match message type.")
      val __fields = descriptor.getFields
      im.actor.server.notify.NotifyProcessorCommands.CheckNotify(
      )
    }
    def descriptor: com.google.protobuf.Descriptors.Descriptor = im.actor.server.notify.NotifyProcessorCommands.descriptor.getNestedTypes.get(3)
    def messageCompanionForField(__field: com.google.protobuf.Descriptors.FieldDescriptor): com.trueaccord.scalapb.GeneratedMessageCompanion[_] = throw new MatchError(__field)
    def enumCompanionForField(__field: com.google.protobuf.Descriptors.FieldDescriptor): com.trueaccord.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__field)
    lazy val defaultInstance = im.actor.server.notify.NotifyProcessorCommands.CheckNotify(
    )
    implicit class CheckNotifyLens[UpperPB](_l: com.trueaccord.lenses.Lens[UpperPB, CheckNotify]) extends com.trueaccord.lenses.ObjectLens[UpperPB, CheckNotify](_l) {
    }
  }
  
  @SerialVersionUID(0L)
  final case class Notify(
      userId: Int = 0
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[Notify] with com.trueaccord.lenses.Updatable[Notify] with im.actor.server.notify.NotifyProcessorCommand {
      @transient
      lazy val serializedSize: Int = {
        var __size = 0
        if (userId != 0) { __size += com.google.protobuf.CodedOutputStream.computeInt32Size(1, userId) }
        __size
      }
      def writeTo(output: com.google.protobuf.CodedOutputStream): Unit = {
        {
          val __v = userId
          if (__v != 0) {
            output.writeInt32(1, __v)
          }
        };
      }
      def mergeFrom(__input: com.google.protobuf.CodedInputStream): im.actor.server.notify.NotifyProcessorCommands.Notify = {
        var __userId = this.userId
        var _done__ = false
        while (!_done__) {
          val _tag__ = __input.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 8 =>
              __userId = __input.readInt32()
            case tag => __input.skipField(tag)
          }
        }
        im.actor.server.notify.NotifyProcessorCommands.Notify(
            userId = __userId
        )
      }
      def withUserId(__v: Int): Notify = copy(userId = __v)
      def getField(__field: com.google.protobuf.Descriptors.FieldDescriptor): scala.Any = {
        __field.getNumber match {
          case 1 => {
            val __t = userId
            if (__t != 0) __t else null
          }
        }
      }
      override def toString: String = com.trueaccord.scalapb.TextFormat.printToUnicodeString(this)
      def companion = im.actor.server.notify.NotifyProcessorCommands.Notify
  }
  
  object Notify extends com.trueaccord.scalapb.GeneratedMessageCompanion[Notify]  {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[Notify]  = this
    def fromFieldsMap(__fieldsMap: Map[com.google.protobuf.Descriptors.FieldDescriptor, scala.Any]): im.actor.server.notify.NotifyProcessorCommands.Notify = {
      require(__fieldsMap.keys.forall(_.getContainingType() == descriptor), "FieldDescriptor does not match message type.")
      val __fields = descriptor.getFields
      im.actor.server.notify.NotifyProcessorCommands.Notify(
        __fieldsMap.getOrElse(__fields.get(0), 0).asInstanceOf[Int]
      )
    }
    def descriptor: com.google.protobuf.Descriptors.Descriptor = im.actor.server.notify.NotifyProcessorCommands.descriptor.getNestedTypes.get(4)
    def messageCompanionForField(__field: com.google.protobuf.Descriptors.FieldDescriptor): com.trueaccord.scalapb.GeneratedMessageCompanion[_] = throw new MatchError(__field)
    def enumCompanionForField(__field: com.google.protobuf.Descriptors.FieldDescriptor): com.trueaccord.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__field)
    lazy val defaultInstance = im.actor.server.notify.NotifyProcessorCommands.Notify(
    )
    implicit class NotifyLens[UpperPB](_l: com.trueaccord.lenses.Lens[UpperPB, Notify]) extends com.trueaccord.lenses.ObjectLens[UpperPB, Notify](_l) {
      def userId: com.trueaccord.lenses.Lens[UpperPB, Int] = field(_.userId)((c_, f_) => c_.copy(userId = f_))
    }
    final val USER_ID_FIELD_NUMBER = 1
  }
  
  @SerialVersionUID(0L)
  final case class CancelNotify(
      userId: Int = 0
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[CancelNotify] with com.trueaccord.lenses.Updatable[CancelNotify] with im.actor.server.notify.NotifyProcessorCommand {
      @transient
      lazy val serializedSize: Int = {
        var __size = 0
        if (userId != 0) { __size += com.google.protobuf.CodedOutputStream.computeInt32Size(1, userId) }
        __size
      }
      def writeTo(output: com.google.protobuf.CodedOutputStream): Unit = {
        {
          val __v = userId
          if (__v != 0) {
            output.writeInt32(1, __v)
          }
        };
      }
      def mergeFrom(__input: com.google.protobuf.CodedInputStream): im.actor.server.notify.NotifyProcessorCommands.CancelNotify = {
        var __userId = this.userId
        var _done__ = false
        while (!_done__) {
          val _tag__ = __input.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 8 =>
              __userId = __input.readInt32()
            case tag => __input.skipField(tag)
          }
        }
        im.actor.server.notify.NotifyProcessorCommands.CancelNotify(
            userId = __userId
        )
      }
      def withUserId(__v: Int): CancelNotify = copy(userId = __v)
      def getField(__field: com.google.protobuf.Descriptors.FieldDescriptor): scala.Any = {
        __field.getNumber match {
          case 1 => {
            val __t = userId
            if (__t != 0) __t else null
          }
        }
      }
      override def toString: String = com.trueaccord.scalapb.TextFormat.printToUnicodeString(this)
      def companion = im.actor.server.notify.NotifyProcessorCommands.CancelNotify
  }
  
  object CancelNotify extends com.trueaccord.scalapb.GeneratedMessageCompanion[CancelNotify]  {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[CancelNotify]  = this
    def fromFieldsMap(__fieldsMap: Map[com.google.protobuf.Descriptors.FieldDescriptor, scala.Any]): im.actor.server.notify.NotifyProcessorCommands.CancelNotify = {
      require(__fieldsMap.keys.forall(_.getContainingType() == descriptor), "FieldDescriptor does not match message type.")
      val __fields = descriptor.getFields
      im.actor.server.notify.NotifyProcessorCommands.CancelNotify(
        __fieldsMap.getOrElse(__fields.get(0), 0).asInstanceOf[Int]
      )
    }
    def descriptor: com.google.protobuf.Descriptors.Descriptor = im.actor.server.notify.NotifyProcessorCommands.descriptor.getNestedTypes.get(5)
    def messageCompanionForField(__field: com.google.protobuf.Descriptors.FieldDescriptor): com.trueaccord.scalapb.GeneratedMessageCompanion[_] = throw new MatchError(__field)
    def enumCompanionForField(__field: com.google.protobuf.Descriptors.FieldDescriptor): com.trueaccord.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__field)
    lazy val defaultInstance = im.actor.server.notify.NotifyProcessorCommands.CancelNotify(
    )
    implicit class CancelNotifyLens[UpperPB](_l: com.trueaccord.lenses.Lens[UpperPB, CancelNotify]) extends com.trueaccord.lenses.ObjectLens[UpperPB, CancelNotify](_l) {
      def userId: com.trueaccord.lenses.Lens[UpperPB, Int] = field(_.userId)((c_, f_) => c_.copy(userId = f_))
    }
    final val USER_ID_FIELD_NUMBER = 1
  }
  
  implicit class NotifyProcessorCommandsLens[UpperPB](_l: com.trueaccord.lenses.Lens[UpperPB, NotifyProcessorCommands]) extends com.trueaccord.lenses.ObjectLens[UpperPB, NotifyProcessorCommands](_l) {
  }
}
