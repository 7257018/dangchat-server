actor-rpc-api/src/main/scala/im/actor/server/api/rpc/service/messaging/HistoryHandlers.scala


//二次开发  by Lining 2016-6-7
import java.time.Instant
import java.time.temporal.ChronoUnit
import im.actor.server.file.UrlBuilderSeed
import im.actor.server.acl.ACLUtils
import im.actor.server.api.http.HttpApiConfig
import im.actor.server.persist.UserSignatureRepo
import im.actor.server.model.UserSignature


  override def doHandleLoadHistory(
    peer:          ApiOutPeer,
    date:          Long,
    mode:          Option[ApiListLoadMode.Value],
    limit:         Int,
    optimizations: IndexedSeq[ApiUpdateOptimization.Value],
    clientData:    ClientData
  ): Future[HandlerResult[ResponseLoadHistory]] =
    authorized(clientData) { implicit client ⇒
      val action = withOutPeerDBIO(peer) {
        val modelPeer = peer.asModel
        for {
          historyOwner ← DBIO.from(getHistoryOwner(modelPeer, client.userId))
          (lastReceivedAt, lastReadAt) ← getLastReceiveReadDates(modelPeer)
          messageModels ← mode match {
            case Some(ApiListLoadMode.Forward)  ⇒ HistoryMessageRepo.findAfter(historyOwner, modelPeer, dateTimeFrom(date), limit.toLong)
            case Some(ApiListLoadMode.Backward) ⇒ HistoryMessageRepo.findBefore(historyOwner, modelPeer, dateTimeFrom(date), limit.toLong)
            case Some(ApiListLoadMode.Both)     ⇒ HistoryMessageRepo.findBidi(historyOwner, modelPeer, dateTimeFrom(date), limit.toLong)
            case _                              ⇒ HistoryMessageRepo.find(historyOwner, modelPeer, endDateTimeFrom(date), limit)
          }
          reactions ← dialogExt.fetchReactions(modelPeer, client.userId, messageModels.map(_.randomId).toSet)

          (messages, userIds, groupIds) = messageModels.view
            .map(_.ofUser(client.userId))
            .foldLeft(Vector.empty[ApiMessageContainer], Set.empty[Int], Set.empty[Int]) {
              case ((msgs, uids, guids), message) ⇒
                message.asStruct(lastReceivedAt, lastReadAt, reactions.getOrElse(message.randomId, Vector.empty)).toOption match {
                  case Some(messageStruct) ⇒
                    val newMsgs = msgs :+ messageStruct

                    val newUserIds = relatedUsers(messageStruct.message) ++
                      (if (message.senderUserId != client.userId)
                        uids + message.senderUserId
                      else
                        uids)

                    (newMsgs, newUserIds, guids ++ messageStruct._relatedGroupIds)
                  case None ⇒ (msgs, uids, guids)
                }
            }
          users ← DBIO.from(Future.sequence(userIds.toVector map (userExt.getApiStruct(_, client.userId, client.authId))))
          groups ← DBIO.from(Future.sequence(groupIds.toVector map (groupExt.getApiStruct(_, client.userId))))
        } yield {
          val stripEntities = optimizations.contains(ApiUpdateOptimization.STRIP_ENTITIES)

          Ok(ResponseLoadHistory(
            history = messages,
            users = if (stripEntities) Vector.empty else users,
            userPeers = users map (u ⇒ ApiUserOutPeer(u.id, u.accessHash)),
            groups = if (stripEntities) Vector.empty else groups,
            groupPeers = groups map (g ⇒ ApiGroupOutPeer(g.id, g.accessHash))
          ))
        }
      }
      //二次开发，保存用户签名。  by Lining  2016-6-7
      updateUserSignature(client.userId)
      db.run(action)
    }
    
    
  /**
   * 更新用户签名  by Lining 2016-6-7
   * @param userId
   */
  private def updateUserSignature(userId: Int) = {
    //得到baseUrl、签名等信息
    val httpConfig = HttpApiConfig.load.get
    val expire = Instant.now.plus(1, ChronoUnit.HOURS).getEpochSecond.toInt
    val seedBytes = UrlBuilderSeed(version = 0, expire = expire, randomPart = ACLUtils.randomHash()).toByteArray
    val baseUrl = s"${httpConfig.baseUri}/v1/files"
    val signatureSecret = ACLUtils.fileUrlBuilderSecret(seedBytes)

    val action = {
      //UserSignatureRepo.createOrUpdate(UserSignature(userId, java.util.Arrays.toString(signatureSecret), expire, baseUrl))
      UserSignatureRepo.createOrUpdate(UserSignature(userId, signatureSecret, expire, baseUrl))
    }
    db.run(action)
  }