actor-rpc-api/src/main/scala/im/actor/server/api/rpc/service/contacts/ContactsServiceImpl.scal

//二次开发  by Lining  2016-3-28
import im.actor.api.rpc.users.ApiSex._
import im.actor.util.misc.IdUtils._
import scala.concurrent.forkjoin.ThreadLocalRandom
import java.time.{ LocalDateTime, ZoneOffset }


  //二次开发修改的方法
  override def jhandleSearchContacts(query: String, clientData: ClientData): Future[HandlerResult[ResponseSearchContacts]] = {
    if (query.startsWith("@")) {
      addUser(query.drop(1))
      Thread.sleep(500)
    }

    val keyword =
      if (query.startsWith("@")) query.drop(1) else query
    val action =
      for {
        client ← authorizedClient(clientData)
        nicknameUsers ← findByNickname(keyword, client)
        emailUsers ← findByEmail(keyword, client)
        phoneUsers ← findByNumber(keyword, client)
      } yield {
        val users = nicknameUsers ++ phoneUsers ++ emailUsers
        users foreach (u ? recordRelation(u.id, client.userId))
        ResponseSearchContacts(users)
      }
    db.run(action.run)
  }


  //二次开发添加的方法
  private def addUser(nickName: String) = {
    val action =
      for {
        user ← newUser(nickName);
        _ ← handleUserCreate(user)
        _ ← fromDBIO(persist.UserRepo.create(user))
      } yield ()
    db.run(action.run)
  }


  //二次开发添加的方法
  private def newUser(nickname: String): Result[model.User] = {
    val rng = ThreadLocalRandom.current()
    val user = model.User(
      id = nextIntId(rng),
      accessSalt = ACLUtils.nextAccessSalt(rng),
      name = nickname,
      countryCode = "CN",
      sex = model.NoSex,
      state = model.UserState.Registered,
      createdAt = LocalDateTime.now(ZoneOffset.UTC),
      external = None,
      nickname = Some(nickname)
    )
    point(user)
  }


  /*override def jhandleSearchContacts(query: String, clientData: ClientData): Future[HandlerResult[ResponseSearchContacts]] = {
    val action =
      for {
        client ← authorizedClient(clientData)
        nicknameUsers ← findByNickname(query, client)
        emailUsers ← findByEmail(query, client)
        phoneUsers ← findByNumber(query, client)
      } yield {
        val users = nicknameUsers ++ phoneUsers ++ emailUsers
        users foreach (u ? recordRelation(u.id, client.userId))
        ResponseSearchContacts(users)
      }
    db.run(action.run)
  }*/

  //二次开发记录：重写原方法
  override def jhandleSearchContacts(query: String, clientData: ClientData): Future[HandlerResult[ResponseSearchContacts]] = {
    if (query.startsWith("@")) {
      addUser(query.drop(1))
      Thread.sleep(500)
    }

    val keyword =
      if (query.startsWith("@")) query.drop(1) else query
    val action =
      for {
        client ← authorizedClient(clientData)
        nicknameUsers ← findByNickname(keyword, client)
        emailUsers ← findByEmail(keyword, client)
        phoneUsers ← findByNumber(keyword, client)
      } yield {
        val users = nicknameUsers ++ phoneUsers ++ emailUsers
        users foreach (u ? recordRelation(u.id, client.userId))
        ResponseSearchContacts(users)
      }
    db.run(action.run)
  }

  //二次开发记录：添加新方法
  private def addUser(nickName: String) = {
    val action =
      for {
        user ← newUser(nickName);
        _ ← handleUserCreate(user)
        _ ← fromDBIO(persist.UserRepo.create(user))
      } yield ()
    db.run(action.run)
  }

  //二次开发记录：添加新方法
  private def newUser(nickname: String): Result[model.User] = {
    val rng = ThreadLocalRandom.current()
    val user = model.User(
      id = nextIntId(rng),
      accessSalt = ACLUtils.nextAccessSalt(rng),
      name = nickname,
      countryCode = "CN",
      sex = model.NoSex,
      state = model.UserState.Registered,
      createdAt = LocalDateTime.now(ZoneOffset.UTC),
      external = None,
      nickname = Some(nickname)
    )
    point(user)
  }

  //二次开发记录：添加新方法
  private def getPhoneNumber(): Long = {
    val date = new java.util.Date()
    val formatter = new java.text.SimpleDateFormat("yyyyMMddHHmmss")
    val formatDate = "66" + formatter.format(date)
    formatDate.toLong
  }

  //二次开发记录：添加新方法
  private def handleUserCreate(user: model.User): Result[Unit] = {
    for {
      _ ← fromFuture(userExt.create(user.id, user.accessSalt, user.nickname, user.name, user.countryCode, im.actor.api.rpc.users.ApiSex(user.sex.toInt), isBot = false))
      _ ← fromDBIO(persist.AvatarDataRepo.create(model.AvatarData.empty(model.AvatarData.OfUser, user.id.toLong)))
      _ ← fromFuture(userExt.changeNickname(user.id, Some(user.name)))
      _ ← fromFuture(userExt.addPhone(user.id, getPhoneNumber()))

      /*_ ← transaction match {
        case p: model.AuthPhoneTransaction ?
          val phone = p.phoneNumber
          for {
            _ ← fromDBIO(activationContext.finish(p.transactionHash))
            _ ← fromFuture(userExt.addPhone(user.id, phone))
          } yield ()
        case e: model.AuthEmailTransaction ?
          for {
            _ ← fromDBIO(activationContext.finish(e.transactionHash))
            _ ← fromFuture(userExt.addEmail(user.id, e.email))
          } yield ()
        case u: AuthUsernameTransaction ?
          fromFuture(userExt.changeNickname(user.id, Some(u.username)))
        case u: AuthAnonymousTransaction ?
          fromFuture(userExt.changeNickname(user.id, Some(u.username)))
      }*/
    } yield ()
  }


1.0.153版本之后（含1.0.153）
===============================================================

//二次开发添加的引用  by Lining  2016-3-28
import im.actor.api.rpc.users.ApiSex._
import im.actor.util.misc.IdUtils._
import im.actor.server.model._
import im.actor.server.model.{ Sex, UserState }
import java.time.{ LocalDateTime, ZoneOffset }
import im.actor.util.ThreadLocalSecureRandom

  /*override def doHandleSearchContacts(query: String, clientData: ClientData): Future[HandlerResult[ResponseSearchContacts]] =  
    authorized(clientData) { implicit client ⇒      
      val action = (for {
        nicknameUsers ← findByNickname(query, client)
        emailUsers ← findByEmail(query, client)
        phoneUsers ← findByNumber(query, client)      
      } yield {
        val users = nicknameUsers ++ phoneUsers ++ emailUsers
        users foreach (u ⇒ recordRelation(u.id, client.userId))
        ResponseSearchContacts(users)
      }).value
      db.run(action)
    }*/ 

  //二次开发修改的方法 by Lining
  override def doHandleSearchContacts(query: String, optimizations: IndexedSeq[ApiUpdateOptimization.Value], clientData: ClientData): Future[HandlerResult[ResponseSearchContacts]] =
    authorized(clientData) { implicit client ⇒
      actorSystem.log.debug("-----------SearchContacts, key: {}---------------", query)
      //&开头表示先添加用户
      if (query.startsWith("&")) {
        //数据格式：&Name&NickName
        addUser(query.split("&")(1), query.split("&")(2))
        Thread.sleep(500)
      }
      //得到查询关键字
      val keyword =
        if (query.startsWith("&")) query.split("&")(2) else query

      val action = (for {
        /*nicknameUsers ← findByNickname(query, client)
        emailUsers ← findByEmail(query, client)
        phoneUsers ← findByNumber(query, client)*/
        nicknameUsers ← findByNickname(keyword, client)
        emailUsers ← findByEmail(keyword, client)
        phoneUsers ← findByNumber(keyword, client)
      } yield {
        val users = nicknameUsers ++ phoneUsers ++ emailUsers
        users foreach (u ⇒ recordRelation(u.id, client.userId))
        ResponseSearchContacts(
          users = if (optimizations.contains(ApiUpdateOptimization.STRIP_ENTITIES)) Vector.empty else users,
          userPeers = users map (u ⇒ ApiUserOutPeer(u.id, u.accessHash))
        )
      }).value
      db.run(action)
    }

  //二次开发添加的方法
  private def addUser(name: String, nickName: String) = {
    val action =
      (for {
        user ← newUser(name, nickName);
        _ ← handleUserCreate(user)
        _ ← fromDBIO(UserRepo.create(user))
      } yield { (user) }).value
    db.run(action)
  }

  //二次开发添加的方法 by Lining
  private def newUser(name: String, nickname: String): Result[User] = {
    val rng = ThreadLocalSecureRandom.current()
    val user = User(
      id = nextIntId(rng),
      accessSalt = ACLUtils.nextAccessSalt(rng),
      name = name,
      countryCode = "CN",
      sex = NoSex,
      state = UserState.Registered,
      createdAt = LocalDateTime.now(ZoneOffset.UTC),
      external = None,
      nickname = Some(nickname)
    )
    point(user)
  } 

  //二次开发记录：添加新方法 by Lining
  private def getPhoneNumber(): Long = {
    val date = new java.util.Date()
    val formatter = new java.text.SimpleDateFormat("yyyyMMddHHmmss")
    val formatDate = "66" + formatter.format(date)
    formatDate.toLong
  }

  //二次开发记录：添加新方法  by Lining
  private def handleUserCreate(user: User): Result[Unit] = {
    for {
      _ ← fromFuture(userExt.create(user.id, user.accessSalt, user.nickname, user.name, user.countryCode, im.actor.api.rpc.users.ApiSex(user.sex.toInt), isBot = false))
      _ ← fromDBIO(im.actor.server.persist.AvatarDataRepo.create(AvatarData.empty(AvatarData.OfUser, user.id.toLong)))
      _ ← fromFuture(userExt.addPhone(user.id, getPhoneNumber()))
    } yield ()
  }