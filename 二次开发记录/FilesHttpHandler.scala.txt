actor-fs-adapters/src/main/scala/im/actor/server/file/local/http/FilesHttpHandler.scala

            get {
              //we use `Segments` because have to match paths like:
              //v1/files/:fileId/:fileName
              //v1/files/:fileId
              path(Segments(0, 1)) { seqName =>
                log.debug("Download file request, fileId: {}", fileId)
                //先得到音频文件名称，如果不是音频文件，则从数据库中得到文件名称
                val fileName = getVoiceFileName(request.uri.toString())
                onComplete(getFile(fileId, fileName)) {
                  case Success(Some(file)) =>
                    log.debug("Serving fileId: {}, file: {} parts", fileId, file)
                    respondWithDefaultHeader(
                      //二次开发，对文件名编码，使中文文件名的文件可正确下载  by Lining  2016-6-14
                      //`Content-Disposition`(attachment, Map("filename" -> file.name))
                      `Content-Disposition`(attachment, Map("filename" -> java.net.URLEncoder.encode(file.name, "UTF-8")))
                    ) {
                      //TODO: remove as soon, as https://github.com/akka/akka/issues/20338 get fixed
                      getFromFileFix(file.toJava)
                    }
                  case Success(None) =>
                    complete(HttpResponse(StatusCodes.NotFound))
                  case Failure(e) =>
                    log.error(e, "Failed to get file content, fileId: {}", fileId)
                    complete(HttpResponse(500))
                }
              }
                      
                      
  /**
   * 得到音频文件名称
   *
   * @param url
   * @return
   */
  private def getVoiceFileName(url: String): String = {
    if (url.contains("voice.opus")) {
      "voice.opus"
    } else if (url.contains("voice.aac")) {
      "voice.aac"
    } else if (url.contains("voice.ogg")) {
      "voice.ogg"
    } else {
      ""
    }
  }                      
                      
  def validateRequest: Directive0 =
    extractRequestContext.flatMap[Unit] { ctx ⇒
      parameters(("signature", "expires".as[Long])) tflatMap {
        case (signature, expiresAt) ⇒
          val request = ctx.request
          val uriWithoutSignature = request.uri.withQuery(request.uri.query() filterNot { case (k, _) ⇒ k == "signature" })
          val notExpired = isNotExpired(expiresAt)
          val calculatedSignature = calculateSignature(request.method, uriWithoutSignature)
          //去掉用户签名校验    by Lining   2016-6-16
          /*if (notExpired && calculatedSignature == signature) pass else {
            log.debug("Failed to validate request: {}, notExpired: {}, signature: {}; calculated signature: {}", notExpired, ctx.request, signature, calculatedSignature)
            reject(InvalidFileSignature)
          }*/
          pass
      }
    }                      