actor-frontend\src\main\scala\im\actor\server\frontend\AuthorizationManager.scala

    def handleRequestDH(randomId: Long, keyId: Long, clientNonce: BitVector, clientKey: BitVector): Unit = {
      withValidKey(keyId) { serverKey ⇒
        withValidSession(randomId) { serverNonce ⇒
          withValidNonce(clientNonce) {
            //简化算法  by Lining 20160524
            //val preMaster = Curve25519.calculateAgreement(serverKey.privat, clientKey.toByteArray)
            val fullNonce = (clientNonce ++ serverNonce).toByteArray
            //简化算法  by Lining 20160524
            val preMaster = fullNonce
            val prfCombined = Cryptos.PRF_SHA_STREEBOG_256()
            val master = prfCombined.calculate(preMaster, "master secret", fullNonce, PRFBytes)
            val verify = prfCombined.calculate(master, "client finished", fullNonce, PRFBytes)
            val randomBytes = new Array[Byte](SignRandomBytes)
            new SecureRandom().nextBytes(randomBytes)
            val verifySign = Curve25519.calculateSignature(randomBytes, serverKey.privat, verify)

            //简化加密算法，注释原算法。  by Lining  20160524
            /*
            val fullNonce = (clientNonce ++ serverNonce).toByteArray ++ serverKey.privat ++ clientKey.toByteArray
            val sha256 = MessageDigest.getInstance("SHA-256")
            sha256.update(fullNonce, 0, fullNonce.length)
            val master = new Array[Byte](256)
            sha256.digest(master, 0, master.length)
            log.info("master key is:{}", master)

            sha256.reset()
            sha256.update(master, 0, master.length)
            val verify = new Array[Byte](32)
            sha256.digest(verify, 0, verify.length)

            sha256.reset()
            sha256.update(verify, 0, verify.length)
            val verifySign = sha256.digest()
            */

            db.run((
              for {
                masterKey ← MasterKeyRepo.create(master)
                _ ← AuthIdRepo.create(masterKey.authId)
              } yield {
                masterKey
              }
            ).transactionally)
              .map { masterKey ⇒
                SendPackage(pSessionId, mb.messageId, ResponseDoDH(randomId, BitVector(verify), BitVector(verifySign)))
              }
              .pipeTo(self)
          }
        }
      }
    }