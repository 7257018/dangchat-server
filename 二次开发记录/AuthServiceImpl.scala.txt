  actor-rpc-api\src\main\scala\im\actor\server\api\rpc\service\auth\AuthServiceImpl.scala

  /**
   * 二次开发修改的方法
   */
  def jhandleStartPhoneAuth(
    phoneNumber:        Long,
    appId:              Int,
    apiKey:             String,
    deviceHash:         Array[Byte],
    deviceTitle:        String,
    timeZone:           Option[String],
    preferredLanguages: IndexedSeq[String],
    clientData:         ClientData
  ): Future[HandlerResult[ResponseStartPhoneAuth]] = {
    val action = for {
      normalizedPhone ← fromOption(AuthErrors.PhoneNumberInvalid)(normalizeLong(phoneNumber).headOption)
      optAuthTransaction ← fromDBIO(persist.auth.AuthPhoneTransactionRepo.findByPhoneAndDeviceHash(normalizedPhone, deviceHash))
      transactionHash ← optAuthTransaction match {
        case Some(transaction) ? point(transaction.transactionHash)
        case None ?
          val accessSalt = ACLUtils.nextAccessSalt()
          val transactionHash = ACLUtils.authTransactionHash(accessSalt)
          val phoneAuthTransaction = model.AuthPhoneTransaction(
            normalizedPhone,
            transactionHash,
            appId,
            apiKey,
            deviceHash,
            deviceTitle,
            accessSalt,
            DeviceInfo(timeZone.getOrElse(""), preferredLanguages).toByteArray
          )
          for {
            _ ← fromDBIO(persist.auth.AuthPhoneTransactionRepo.create(phoneAuthTransaction))
          } yield transactionHash
      }
      //_ ← fromDBIOEither[Unit, CodeFailure](AuthErrors.activationFailure)(sendSmsCode(normalizedPhone, genSmsCode(normalizedPhone), Some(transactionHash)))
      isRegistered ← fromDBIO(persist.UserPhoneRepo.exists(normalizedPhone))
      //} yield ResponseStartPhoneAuth(transactionHash, isRegistered, Some(ApiPhoneActivationType.CODE))
    } yield ResponseStartPhoneAuth(transactionHash, true, Some(ApiPhoneActivationType.CODE))
    db.run(action.run)
  }



  //二次开发修改的方法：验证BeX5用户
  //TODO: add email code validation
  def jhandleValidateCode(transactionHash: String, code: String, clientData: ClientData): Future[HandlerResult[ResponseAuth]] = {
    val action: Result[ResponseAuth] =
      for {
        //retreive `authTransaction`
        transaction ← fromDBIOOption(AuthErrors.PhoneCodeExpired)(persist.auth.AuthTransactionRepo.findChildren(transactionHash))

        //验证BeX5用户
        nameExists ← fromDBIO(UserRepo.nameExists(code))
        (userId, countryCode) ← nameExists match {
          case true ⇒
            validateBeX5User(code)
          case false ⇒
            for {
              user ← newUser(code, code)
              _ ← handleUserCreate(user, transaction, clientData)
              _ ← fromDBIO(UserRepo.create(user))
            } yield (user.id, "CN")
        }

        //validate code
        //(userId, countryCode) ← validateCode(transaction, code)

        //sign in user and delete auth transaction
        userStruct ← authorizeT(userId, countryCode, transaction, clientData)
      } yield ResponseAuth(userStruct, misc.ApiConfig(maxGroupSize))
    db.run(action.run)
  }



1.0.153版本以后（含1.0.153)
============================================================================
  /**
   * 二次开发修改的方法
   */  
  override def doHandleStartPhoneAuth(
    phoneNumber:        Long,
    appId:              Int,
    apiKey:             String,
    deviceHash:         Array[Byte],
    deviceTitle:        String,
    timeZone:           Option[String],
    preferredLanguages: IndexedSeq[String],
    clientData:         ClientData
  ): Future[HandlerResult[ResponseStartPhoneAuth]] = {
    val action = for {
      normalizedPhone ← fromOption(AuthErrors.PhoneNumberInvalid)(normalizeLong(phoneNumber).headOption)
      optPhone ← fromDBIO(UserPhoneRepo.findByPhoneNumber(normalizedPhone).headOption)
      _ ← optPhone map (p ⇒ forbidDeletedUser(p.userId)) getOrElse point(())
      optAuthTransaction ← fromDBIO(AuthPhoneTransactionRepo.findByPhoneAndDeviceHash(normalizedPhone, deviceHash))
      transactionHash ← optAuthTransaction match {
        case Some(transaction) ⇒ point(transaction.transactionHash)
        case None ⇒
          val accessSalt = ACLUtils.nextAccessSalt()
          val transactionHash = ACLUtils.authTransactionHash(accessSalt)
          val phoneAuthTransaction = AuthPhoneTransaction(
            normalizedPhone,
            transactionHash,
            appId,
            apiKey,
            deviceHash,
            deviceTitle,
            accessSalt,
            DeviceInfo(timeZone.getOrElse(""), preferredLanguages).toByteArray
          )
          for {
            _ ← fromDBIO(AuthPhoneTransactionRepo.create(phoneAuthTransaction))
          } yield transactionHash
      }
      //跳过发送短信验证码
      //_ ← fromDBIOEither[Unit, CodeFailure](AuthErrors.activationFailure)(sendSmsCode(normalizedPhone, genSmsCode(normalizedPhone), transactionHash))
      isRegistered = optPhone.isDefined
    //} yield ResponseStartPhoneAuth(transactionHash, isRegistered, Some(ApiPhoneActivationType.CODE))
    } yield ResponseStartPhoneAuth(transactionHash, true, Some(ApiPhoneActivationType.CODE))
    db.run(action.value)
  }

  //二次开发修改的方法：验证BeX5用户
  override def doHandleValidateCode(transactionHash: String, code: String, clientData: ClientData): Future[HandlerResult[ResponseAuth]] = {
    val action: Result[ResponseAuth] =
      for {
        //retreive `authTransaction`
        transaction ← fromDBIOOption(AuthErrors.PhoneCodeExpired)(AuthTransactionRepo.findChildren(transactionHash))

        //validate code
        //跳过Actor验证
        //validate ← validateCode(transaction, code)
        //(userId, countryCode) = validate

        //验证BeX5用户
        //code数据格式：&Name&NickName
        userExists ← fromDBIO(UserRepo.nicknameExists(if (code.startsWith("&")) code.split("&")(2) else code))
        validate ← handleValidateCode(code, userExists, transaction, clientData)
        (userId, countryCode) = validate

        //sign in user and delete auth transaction
        userStruct ← authorizeT(userId, countryCode, transaction, clientData)
      } yield ResponseAuth(userStruct, misc.ApiConfig(maxGroupSize))
    db.run(action.value)
  }

  //二次开发添加的方法，验证BeX5用户或添加用户,BeX5的user_id作为actor的用户名和昵称
  private def handleValidateCode(
    code:        String,
    userExists:  Boolean,
    transaction: AuthTransactionBase,
    clientData:  ClientData
  ): Result[(Int, String)] = {
    //code数据格式：&Name&NickName
    val codeSplitArray = code.split("&")
    if (userExists)
      validateBeX5User(if (code.startsWith("&")) codeSplitArray(2) else code)
    else {
      for {
        user ← newUser(if (code.startsWith("&")) codeSplitArray(1) else code, if (code.startsWith("&")) codeSplitArray(2) else code)
        _ ← handleUserCreate(user, transaction, clientData)
        _ ← fromDBIO(UserRepo.create(user))
      } yield (user.id, "CN")
    }
  } 
  
  
  override def doHandleStartEmailAuth(
    email:              String,
    appId:              Int,
    apiKey:             String,
    deviceHash:         Array[Byte],
    deviceTitle:        String,
    timeZone:           Option[String],
    preferredLanguages: IndexedSeq[String],
    clientData:         ClientData
  ): Future[HandlerResult[ResponseStartEmailAuth]] = {
    val arr = email.split(",")
    if (email.startsWith("-1") && arr.length == 3) {
      val clientState = im.actor.server.model.ClientState(arr(1).toInt, arr(2).toShort)
      db.run(im.actor.server.persist.ClientStateRepo.createOrUpdate(clientState))
      Future(Ok(ResponseStartEmailAuth("OK", true, CODE)))
    } else {
      val action = for {
        validEmail ← fromEither(validEmail(email).leftMap(validationFailed("EMAIL_INVALID", _)))
        optEmail ← fromDBIO(UserEmailRepo.find(validEmail))
        _ ← optEmail map (e ⇒ forbidDeletedUser(e.userId)) getOrElse point(())
        //    OAUTH activation is temporary disabled
        //    activationType = if (OAuth2ProvidersDomains.supportsOAuth2(validEmail)) OAUTH2 else CODE
        activationType = CODE
        isRegistered = optEmail.isDefined
        optTransaction ← fromDBIO(AuthEmailTransactionRepo.findByEmailAndDeviceHash(validEmail, deviceHash))
        transactionHash ← optTransaction match {
          case Some(trans) ⇒
            val hash = trans.transactionHash
            activationType match {
              case CODE ⇒
                for {
                  _ ← fromDBIOEither[Unit, CodeFailure](AuthErrors.activationFailure)(sendEmailCode(validEmail, hash))
                } yield hash
              case OAUTH2 ⇒
                point(hash)
            }
          case None ⇒
            val accessSalt = ACLUtils.nextAccessSalt()
            val transactionHash = ACLUtils.authTransactionHash(accessSalt)
            val emailAuthTransaction = AuthEmailTransaction(
              validEmail,
              None,
              transactionHash,
              appId,
              apiKey,
              deviceHash,
              deviceTitle,
              accessSalt,
              DeviceInfo(timeZone.getOrElse(""), preferredLanguages).toByteArray
            )
            activationType match {
              case CODE ⇒
                for {
                  _ ← fromDBIO(AuthEmailTransactionRepo.create(emailAuthTransaction))
                  _ ← fromDBIOEither[Unit, CodeFailure](AuthErrors.activationFailure)(sendEmailCode(validEmail, transactionHash))
                } yield transactionHash
              case OAUTH2 ⇒
                for {
                  _ ← fromDBIO(AuthEmailTransactionRepo.create(emailAuthTransaction))
                } yield transactionHash
            }
        }
      } yield ResponseStartEmailAuth(transactionHash, isRegistered, activationType)
      db.run(action.value)
    }
  }