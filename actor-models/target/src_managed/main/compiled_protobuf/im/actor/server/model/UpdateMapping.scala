// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package im.actor.server.model


import im.actor.server.model.ModelTypeMappers._

@SerialVersionUID(0L)
final case class UpdateMapping(
    default: Option[im.actor.server.model.SerializedUpdate] = None,
    custom: Map[Int, im.actor.server.model.SerializedUpdate] = Map.empty
    ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[UpdateMapping] with com.trueaccord.lenses.Updatable[UpdateMapping] {
    @transient
    lazy val serializedSize: Int = {
      var __size = 0
      if (default.isDefined) { __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(default.get.serializedSize) + default.get.serializedSize }
      custom.foreach(custom => __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(im.actor.server.model.UpdateMapping._typemapper_custom.toBase(custom).serializedSize) + im.actor.server.model.UpdateMapping._typemapper_custom.toBase(custom).serializedSize)
      __size
    }
    def writeTo(output: com.google.protobuf.CodedOutputStream): Unit = {
      default.foreach { __v => 
        output.writeTag(1, 2)
        output.writeRawVarint32(__v.serializedSize)
        __v.writeTo(output)
      };
      custom.foreach { __v => 
        output.writeTag(2, 2)
        output.writeRawVarint32(im.actor.server.model.UpdateMapping._typemapper_custom.toBase(__v).serializedSize)
        im.actor.server.model.UpdateMapping._typemapper_custom.toBase(__v).writeTo(output)
      };
    }
    def mergeFrom(__input: com.google.protobuf.CodedInputStream): im.actor.server.model.UpdateMapping = {
      var __default = this.default
      val __custom = (scala.collection.immutable.Map.newBuilder[Int, im.actor.server.model.SerializedUpdate] ++= this.custom)
      var _done__ = false
      while (!_done__) {
        val _tag__ = __input.readTag()
        _tag__ match {
          case 0 => _done__ = true
          case 10 =>
            __default = Some(com.trueaccord.scalapb.LiteParser.readMessage(__input, __default.getOrElse(im.actor.server.model.SerializedUpdate.defaultInstance)))
          case 18 =>
            __custom += im.actor.server.model.UpdateMapping._typemapper_custom.toCustom(com.trueaccord.scalapb.LiteParser.readMessage(__input, im.actor.server.model.UpdateMapping.CustomEntry.defaultInstance))
          case tag => __input.skipField(tag)
        }
      }
      im.actor.server.model.UpdateMapping(
          default = __default,
          custom = __custom.result()
      )
    }
    def getDefault: im.actor.server.model.SerializedUpdate = default.getOrElse(im.actor.server.model.SerializedUpdate.defaultInstance)
    def clearDefault: UpdateMapping = copy(default = None)
    def withDefault(__v: im.actor.server.model.SerializedUpdate): UpdateMapping = copy(default = Some(__v))
    def clearCustom = copy(custom = Map.empty)
    def addCustom(__vs: (Int, im.actor.server.model.SerializedUpdate)*): UpdateMapping = addAllCustom(__vs)
    def addAllCustom(__vs: TraversableOnce[(Int, im.actor.server.model.SerializedUpdate)]): UpdateMapping = copy(custom = custom ++ __vs)
    def withCustom(__v: Map[Int, im.actor.server.model.SerializedUpdate]): UpdateMapping = copy(custom = __v)
    def getField(__field: com.google.protobuf.Descriptors.FieldDescriptor): scala.Any = {
      __field.getNumber match {
        case 1 => default.getOrElse(null)
        case 2 => custom.map(im.actor.server.model.UpdateMapping._typemapper_custom.toBase(_))
      }
    }
    override def toString: String = com.trueaccord.scalapb.TextFormat.printToUnicodeString(this)
    def companion = im.actor.server.model.UpdateMapping
}

object UpdateMapping extends com.trueaccord.scalapb.GeneratedMessageCompanion[UpdateMapping]  {
  implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[UpdateMapping]  = this
  def fromFieldsMap(__fieldsMap: Map[com.google.protobuf.Descriptors.FieldDescriptor, scala.Any]): im.actor.server.model.UpdateMapping = {
    require(__fieldsMap.keys.forall(_.getContainingType() == descriptor), "FieldDescriptor does not match message type.")
    val __fields = descriptor.getFields
    im.actor.server.model.UpdateMapping(
      __fieldsMap.get(__fields.get(0)).asInstanceOf[Option[im.actor.server.model.SerializedUpdate]],
      __fieldsMap.getOrElse(__fields.get(1), Nil).asInstanceOf[Seq[im.actor.server.model.UpdateMapping.CustomEntry]].map(im.actor.server.model.UpdateMapping._typemapper_custom.toCustom(_))(scala.collection.breakOut)
    )
  }
  def descriptor: com.google.protobuf.Descriptors.Descriptor = ModelProto.descriptor.getMessageTypes.get(1)
  def messageCompanionForField(__field: com.google.protobuf.Descriptors.FieldDescriptor): com.trueaccord.scalapb.GeneratedMessageCompanion[_] = {
    require(__field.getContainingType() == descriptor, "FieldDescriptor does not match message type.")
    var __out: com.trueaccord.scalapb.GeneratedMessageCompanion[_] = null
    __field.getNumber match {
      case 1 => __out = im.actor.server.model.SerializedUpdate
      case 2 => __out = im.actor.server.model.UpdateMapping.CustomEntry
    }
  __out
  }
  def enumCompanionForField(__field: com.google.protobuf.Descriptors.FieldDescriptor): com.trueaccord.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__field)
  lazy val defaultInstance = im.actor.server.model.UpdateMapping(
  )
  @SerialVersionUID(0L)
  final case class CustomEntry(
      key: Int = 0,
      value: Option[im.actor.server.model.SerializedUpdate] = None
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[CustomEntry] with com.trueaccord.lenses.Updatable[CustomEntry] {
      @transient
      lazy val serializedSize: Int = {
        var __size = 0
        if (key != 0) { __size += com.google.protobuf.CodedOutputStream.computeInt32Size(1, key) }
        if (value.isDefined) { __size += 1 + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(value.get.serializedSize) + value.get.serializedSize }
        __size
      }
      def writeTo(output: com.google.protobuf.CodedOutputStream): Unit = {
        {
          val __v = key
          if (__v != 0) {
            output.writeInt32(1, __v)
          }
        };
        value.foreach { __v => 
          output.writeTag(2, 2)
          output.writeRawVarint32(__v.serializedSize)
          __v.writeTo(output)
        };
      }
      def mergeFrom(__input: com.google.protobuf.CodedInputStream): im.actor.server.model.UpdateMapping.CustomEntry = {
        var __key = this.key
        var __value = this.value
        var _done__ = false
        while (!_done__) {
          val _tag__ = __input.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 8 =>
              __key = __input.readInt32()
            case 18 =>
              __value = Some(com.trueaccord.scalapb.LiteParser.readMessage(__input, __value.getOrElse(im.actor.server.model.SerializedUpdate.defaultInstance)))
            case tag => __input.skipField(tag)
          }
        }
        im.actor.server.model.UpdateMapping.CustomEntry(
            key = __key,
            value = __value
        )
      }
      def withKey(__v: Int): CustomEntry = copy(key = __v)
      def getValue: im.actor.server.model.SerializedUpdate = value.getOrElse(im.actor.server.model.SerializedUpdate.defaultInstance)
      def clearValue: CustomEntry = copy(value = None)
      def withValue(__v: im.actor.server.model.SerializedUpdate): CustomEntry = copy(value = Some(__v))
      def getField(__field: com.google.protobuf.Descriptors.FieldDescriptor): scala.Any = {
        __field.getNumber match {
          case 1 => {
            val __t = key
            if (__t != 0) __t else null
          }
          case 2 => value.getOrElse(null)
        }
      }
      override def toString: String = com.trueaccord.scalapb.TextFormat.printToUnicodeString(this)
      def companion = im.actor.server.model.UpdateMapping.CustomEntry
  }
  
  object CustomEntry extends com.trueaccord.scalapb.GeneratedMessageCompanion[CustomEntry]  {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[CustomEntry]  = this
    def fromFieldsMap(__fieldsMap: Map[com.google.protobuf.Descriptors.FieldDescriptor, scala.Any]): im.actor.server.model.UpdateMapping.CustomEntry = {
      require(__fieldsMap.keys.forall(_.getContainingType() == descriptor), "FieldDescriptor does not match message type.")
      val __fields = descriptor.getFields
      im.actor.server.model.UpdateMapping.CustomEntry(
        __fieldsMap.getOrElse(__fields.get(0), 0).asInstanceOf[Int],
        __fieldsMap.get(__fields.get(1)).asInstanceOf[Option[im.actor.server.model.SerializedUpdate]]
      )
    }
    def descriptor: com.google.protobuf.Descriptors.Descriptor = im.actor.server.model.UpdateMapping.descriptor.getNestedTypes.get(0)
    def messageCompanionForField(__field: com.google.protobuf.Descriptors.FieldDescriptor): com.trueaccord.scalapb.GeneratedMessageCompanion[_] = {
      require(__field.getContainingType() == descriptor, "FieldDescriptor does not match message type.")
      var __out: com.trueaccord.scalapb.GeneratedMessageCompanion[_] = null
      __field.getNumber match {
        case 2 => __out = im.actor.server.model.SerializedUpdate
      }
    __out
    }
    def enumCompanionForField(__field: com.google.protobuf.Descriptors.FieldDescriptor): com.trueaccord.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__field)
    lazy val defaultInstance = im.actor.server.model.UpdateMapping.CustomEntry(
    )
    implicit class CustomEntryLens[UpperPB](_l: com.trueaccord.lenses.Lens[UpperPB, CustomEntry]) extends com.trueaccord.lenses.ObjectLens[UpperPB, CustomEntry](_l) {
      def key: com.trueaccord.lenses.Lens[UpperPB, Int] = field(_.key)((c_, f_) => c_.copy(key = f_))
      def value: com.trueaccord.lenses.Lens[UpperPB, im.actor.server.model.SerializedUpdate] = field(_.getValue)((c_, f_) => c_.copy(value = Some(f_)))
      def optionalValue: com.trueaccord.lenses.Lens[UpperPB, Option[im.actor.server.model.SerializedUpdate]] = field(_.value)((c_, f_) => c_.copy(value = f_))
    }
    final val KEY_FIELD_NUMBER = 1
    final val VALUE_FIELD_NUMBER = 2
    implicit val keyValueMapper: com.trueaccord.scalapb.TypeMapper[im.actor.server.model.UpdateMapping.CustomEntry, (Int, im.actor.server.model.SerializedUpdate)] =
      com.trueaccord.scalapb.TypeMapper[im.actor.server.model.UpdateMapping.CustomEntry, (Int, im.actor.server.model.SerializedUpdate)](__m => (__m.key, __m.getValue))(__p => im.actor.server.model.UpdateMapping.CustomEntry(__p._1, Some(__p._2)))
  }
  
  implicit class UpdateMappingLens[UpperPB](_l: com.trueaccord.lenses.Lens[UpperPB, UpdateMapping]) extends com.trueaccord.lenses.ObjectLens[UpperPB, UpdateMapping](_l) {
    def default: com.trueaccord.lenses.Lens[UpperPB, im.actor.server.model.SerializedUpdate] = field(_.getDefault)((c_, f_) => c_.copy(default = Some(f_)))
    def optionalDefault: com.trueaccord.lenses.Lens[UpperPB, Option[im.actor.server.model.SerializedUpdate]] = field(_.default)((c_, f_) => c_.copy(default = f_))
    def custom: com.trueaccord.lenses.Lens[UpperPB, Map[Int, im.actor.server.model.SerializedUpdate]] = field(_.custom)((c_, f_) => c_.copy(custom = f_))
  }
  final val DEFAULT_FIELD_NUMBER = 1
  final val CUSTOM_FIELD_NUMBER = 2
  private val _typemapper_custom: com.trueaccord.scalapb.TypeMapper[im.actor.server.model.UpdateMapping.CustomEntry, (Int, im.actor.server.model.SerializedUpdate)] = implicitly[com.trueaccord.scalapb.TypeMapper[im.actor.server.model.UpdateMapping.CustomEntry, (Int, im.actor.server.model.SerializedUpdate)]]
}
